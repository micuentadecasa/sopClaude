# Build Implementation Prompt

Based on the system architecture and SOP, generate the core implementation code for the agent. Create production-ready code with proper structure, error handling, and documentation.

## Implementation Code Generation

Generate a complete Python implementation that follows the architecture and implements the SOP workflows:

### Main Agent Implementation (agent-core.py)

```python
#!/usr/bin/env python3
"""
Agent Core Implementation

This module implements the main agent logic following the Standard Operating Procedure.
Generated by Claude SOP Generator.
"""

import asyncio
import logging
import json
import time
from typing import Dict, Any, Optional, List, Union
from dataclasses import dataclass, asdict
from datetime import datetime, timedelta
from abc import ABC, abstractmethod

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@dataclass
class AgentConfig:
    """Configuration parameters for the agent"""
    name: str = "Generated Agent"
    version: str = "1.0.0"
    timeout: int = 30
    max_retries: int = 3
    cache_ttl: int = 300
    debug_mode: bool = False

class AgentError(Exception):
    """Base exception for agent errors"""
    pass

class ValidationError(AgentError):
    """Input validation errors"""
    pass

class ProcessingError(AgentError):
    """Processing workflow errors"""
    pass

class IntegrationError(AgentError):
    """External integration errors"""
    pass

class Agent:
    """
    Main agent implementation following the SOP.
    
    This class orchestrates the entire workflow from input validation
    through processing to output generation.
    """
    
    def __init__(self, config: AgentConfig):
        self.config = config
        self.start_time = datetime.now()
        self.request_count = 0
        
        # Initialize components
        self.validator = InputValidator(config)
        self.processor = WorkflowProcessor(config)
        self.integrations = IntegrationManager(config)
        self.cache = CacheManager(config)
        
        logger.info(f"Agent initialized: {config.name} v{config.version}")
    
    async def process_request(self, request: Dict[str, Any]) -> Dict[str, Any]:
        """
        Main entry point for processing requests.
        
        Implements the complete SOP workflow:
        1. Input validation
        2. Request routing
        3. Processing
        4. Response generation
        
        Args:
            request: Input request dictionary
            
        Returns:
            Processed response dictionary
            
        Raises:
            ValidationError: If input validation fails
            ProcessingError: If processing workflow fails
        """
        request_id = f"req_{int(time.time())}_{self.request_count}"
        self.request_count += 1
        
        start_time = time.time()
        logger.info(f"Processing request {request_id}")
        
        try:
            # Step 1: Validate input
            validated_request = await self.validator.validate(request)
            logger.debug(f"Request {request_id} validated successfully")
            
            # Step 2: Process through workflow
            result = await self.processor.process(validated_request)
            logger.debug(f"Request {request_id} processed successfully")
            
            # Step 3: Generate response
            response = await self._generate_response(result, request_id)
            
            # Log metrics
            processing_time = time.time() - start_time
            logger.info(f"Request {request_id} completed in {processing_time:.2f}s")
            
            return response
            
        except Exception as e:
            processing_time = time.time() - start_time
            logger.error(f"Request {request_id} failed after {processing_time:.2f}s: {e}")
            return await self._handle_error(e, request_id)
    
    async def _generate_response(self, result: Dict[str, Any], request_id: str) -> Dict[str, Any]:
        """Generate final response format"""
        return {
            "request_id": request_id,
            "status": "success",
            "data": result,
            "metadata": {
                "agent": self.config.name,
                "version": self.config.version,
                "timestamp": datetime.now().isoformat(),
                "processing_time": time.time()
            }
        }
    
    async def _handle_error(self, error: Exception, request_id: str) -> Dict[str, Any]:
        """Handle and format error responses"""
        error_type = type(error).__name__
        error_message = str(error)
        
        return {
            "request_id": request_id,
            "status": "error",
            "error": {
                "type": error_type,
                "message": error_message
            },
            "metadata": {
                "agent": self.config.name,
                "timestamp": datetime.now().isoformat()
            }
        }

class InputValidator:
    """Handles input validation according to SOP requirements"""
    
    def __init__(self, config: AgentConfig):
        self.config = config
    
    async def validate(self, request: Dict[str, Any]) -> Dict[str, Any]:
        """
        Validate input request format and content.
        
        Implements validation rules from the SOP.
        """
        if not isinstance(request, dict):
            raise ValidationError("Request must be a dictionary")
        
        # Add specific validation logic here based on your SOP
        # Example validations:
        required_fields = ["type", "data"]
        for field in required_fields:
            if field not in request:
                raise ValidationError(f"Required field missing: {field}")
        
        # Type-specific validation
        request_type = request.get("type")
        if not request_type:
            raise ValidationError("Request type cannot be empty")
        
        return request

class WorkflowProcessor:
    """Implements the main SOP workflow logic"""
    
    def __init__(self, config: AgentConfig):
        self.config = config
    
    async def process(self, request: Dict[str, Any]) -> Dict[str, Any]:
        """
        Process request through the SOP workflow.
        
        Implements decision trees and workflow steps from the SOP.
        """
        request_type = request.get("type")
        
        # Route to appropriate handler based on SOP decision tree
        if request_type == "simple":
            return await self._handle_simple_request(request)
        elif request_type == "complex":
            return await self._handle_complex_request(request)
        else:
            return await self._handle_default_request(request)
    
    async def _handle_simple_request(self, request: Dict[str, Any]) -> Dict[str, Any]:
        """Handle simple request type"""
        # Implement simple workflow from SOP
        return {"result": "Simple processing completed", "data": request["data"]}
    
    async def _handle_complex_request(self, request: Dict[str, Any]) -> Dict[str, Any]:
        """Handle complex request type"""
        # Implement complex workflow from SOP
        return {"result": "Complex processing completed", "data": request["data"]}
    
    async def _handle_default_request(self, request: Dict[str, Any]) -> Dict[str, Any]:
        """Handle default/unknown request types"""
        # Implement default workflow from SOP
        return {"result": "Default processing completed", "data": request["data"]}

class IntegrationManager:
    """Manages external system integrations"""
    
    def __init__(self, config: AgentConfig):
        self.config = config
        self.connections = {}
    
    async def call_external_service(self, service: str, request: Dict[str, Any]) -> Dict[str, Any]:
        """Call external service with proper error handling"""
        try:
            # Implement integration calls based on SOP specifications
            logger.info(f"Calling external service: {service}")
            
            # Simulate external call
            await asyncio.sleep(0.1)
            
            return {"status": "success", "data": f"Response from {service}"}
            
        except Exception as e:
            logger.error(f"External service {service} failed: {e}")
            raise IntegrationError(f"Service {service} unavailable")

class CacheManager:
    """Manages caching according to SOP optimization strategy"""
    
    def __init__(self, config: AgentConfig):
        self.config = config
        self.cache = {}
        self.ttl = {}
    
    async def get(self, key: str) -> Optional[Any]:
        """Get value from cache"""
        if key in self.cache:
            if self._is_valid(key):
                return self.cache[key]
            else:
                del self.cache[key]
                del self.ttl[key]
        return None
    
    async def set(self, key: str, value: Any, ttl: Optional[int] = None) -> None:
        """Set value in cache"""
        self.cache[key] = value
        self.ttl[key] = time.time() + (ttl or self.config.cache_ttl)
    
    def _is_valid(self, key: str) -> bool:
        """Check if cache entry is still valid"""
        return key in self.ttl and time.time() < self.ttl[key]

# FastAPI application setup
try:
    from fastapi import FastAPI, HTTPException
    from pydantic import BaseModel
    
    app = FastAPI(title="Generated Agent API", version="1.0.0")
    
    # Initialize agent
    config = AgentConfig()
    agent = Agent(config)
    
    class RequestModel(BaseModel):
        type: str
        data: dict
        metadata: Optional[dict] = None
    
    @app.post("/process")
    async def process_request(request: RequestModel):
        """Process agent request"""
        try:
            result = await agent.process_request(request.dict())
            return result
        except ValidationError as e:
            raise HTTPException(status_code=400, detail=str(e))
        except Exception as e:
            raise HTTPException(status_code=500, detail=str(e))
    
    @app.get("/health")
    async def health_check():
        """Health check endpoint"""
        uptime = datetime.now() - agent.start_time
        return {
            "status": "healthy",
            "uptime": str(uptime),
            "requests_processed": agent.request_count
        }

except ImportError:
    logger.warning("FastAPI not available. API endpoints disabled.")

if __name__ == "__main__":
    # CLI interface for testing
    import sys
    
    if len(sys.argv) > 1:
        test_request = {"type": sys.argv[1], "data": {"message": " ".join(sys.argv[2:])}}
    else:
        test_request = {"type": "simple", "data": {"message": "Hello, World!"}}
    
    config = AgentConfig(debug_mode=True)
    agent = Agent(config)
    
    async def main():
        result = await agent.process_request(test_request)
        print(json.dumps(result, indent=2))
    
    asyncio.run(main())
```

## Additional Requirements

Include these implementation features:

1. **Error Handling**: Comprehensive exception handling with proper error types
2. **Logging**: Structured logging for debugging and monitoring
3. **Configuration**: Environment-based configuration management
4. **Testing Hooks**: Built-in testing capabilities
5. **Performance Monitoring**: Basic metrics collection
6. **API Interface**: RESTful API endpoints using FastAPI
7. **CLI Interface**: Command-line interface for testing
8. **Documentation**: Comprehensive docstrings and comments

## Installation Requirements

Generate a requirements.txt file:
```
fastapi>=0.68.0
uvicorn>=0.15.0
pydantic>=1.8.0
aiohttp>=3.7.0
python-dotenv>=0.19.0
```

Generate production-ready code that implements the complete SOP workflow.