# Build Integrations Prompt

Based on the integration specifications from Stage 2, generate implementation code for all external system integrations.

## Integration Implementation Code

Create modular integration code that handles all external service connections according to the specifications:

### Integration Manager Implementation (integrations.py)

```python
#!/usr/bin/env python3
"""
External Integrations Implementation

This module handles all external system integrations with proper error handling,
retry logic, and performance optimization.
Generated by Claude SOP Generator.
"""

import asyncio
import aiohttp
import json
import time
import logging
from typing import Dict, Any, Optional, List, Union
from dataclasses import dataclass
from datetime import datetime, timedelta
from abc import ABC, abstractmethod
import os
from urllib.parse import urljoin

logger = logging.getLogger(__name__)

@dataclass
class IntegrationConfig:
    """Configuration for external integrations"""
    base_url: str
    api_key: Optional[str] = None
    timeout: int = 30
    max_retries: int = 3
    rate_limit: int = 100  # requests per minute
    circuit_breaker_threshold: int = 5
    circuit_breaker_timeout: int = 60

class IntegrationError(Exception):
    """Base exception for integration errors"""
    pass

class RateLimitError(IntegrationError):
    """Rate limit exceeded"""
    pass

class CircuitBreakerOpen(IntegrationError):
    """Circuit breaker is open"""
    pass

class ExternalServiceError(IntegrationError):
    """External service returned an error"""
    pass

class BaseIntegration(ABC):
    """Base class for all integrations"""
    
    def __init__(self, config: IntegrationConfig):
        self.config = config
        self.session: Optional[aiohttp.ClientSession] = None
        self.rate_limiter = RateLimiter(config.rate_limit)
        self.circuit_breaker = CircuitBreaker(
            threshold=config.circuit_breaker_threshold,
            timeout=config.circuit_breaker_timeout
        )
        self.request_count = 0
        self.error_count = 0
    
    async def __aenter__(self):
        """Async context manager entry"""
        await self.connect()
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Async context manager exit"""
        await self.disconnect()
    
    async def connect(self):
        """Initialize connection session"""
        if not self.session:
            timeout = aiohttp.ClientTimeout(total=self.config.timeout)
            self.session = aiohttp.ClientSession(timeout=timeout)
            logger.info(f"Connected to {self.__class__.__name__}")
    
    async def disconnect(self):
        """Close connection session"""
        if self.session:
            await self.session.close()
            self.session = None
            logger.info(f"Disconnected from {self.__class__.__name__}")
    
    async def make_request(self, method: str, endpoint: str, **kwargs) -> Dict[str, Any]:
        """
        Make HTTP request with error handling and retries
        
        Args:
            method: HTTP method (GET, POST, etc.)
            endpoint: API endpoint
            **kwargs: Additional request parameters
            
        Returns:
            Response data
            
        Raises:
            IntegrationError: On request failure
        """
        if not self.session:
            await self.connect()
        
        # Check circuit breaker
        if self.circuit_breaker.is_open():
            raise CircuitBreakerOpen(f"Circuit breaker is open for {self.__class__.__name__}")
        
        # Check rate limit
        await self.rate_limiter.acquire()
        
        url = urljoin(self.config.base_url, endpoint)
        headers = self._get_headers()
        
        for attempt in range(self.config.max_retries + 1):
            try:
                self.request_count += 1
                
                async with self.session.request(method, url, headers=headers, **kwargs) as response:
                    response_data = await self._handle_response(response)
                    
                    # Request successful, record success
                    self.circuit_breaker.record_success()
                    return response_data
                    
            except (aiohttp.ClientError, asyncio.TimeoutError) as e:
                self.error_count += 1
                self.circuit_breaker.record_failure()
                
                if attempt < self.config.max_retries:
                    wait_time = 2 ** attempt  # Exponential backoff
                    logger.warning(f"Request failed, retrying in {wait_time}s: {e}")
                    await asyncio.sleep(wait_time)
                else:
                    logger.error(f"Request failed after {self.config.max_retries} retries: {e}")
                    raise IntegrationError(f"Request failed: {e}")
    
    async def _handle_response(self, response: aiohttp.ClientResponse) -> Dict[str, Any]:
        """Handle HTTP response"""
        if response.status == 429:
            raise RateLimitError("Rate limit exceeded")
        
        if response.status >= 400:
            error_text = await response.text()
            raise ExternalServiceError(f"HTTP {response.status}: {error_text}")
        
        try:
            return await response.json()
        except json.JSONDecodeError:
            return {"content": await response.text()}
    
    def _get_headers(self) -> Dict[str, str]:
        """Get request headers"""
        headers = {
            "Content-Type": "application/json",
            "User-Agent": "Generated-Agent/1.0"
        }
        
        if self.config.api_key:
            headers["Authorization"] = f"Bearer {self.config.api_key}"
        
        return headers
    
    @abstractmethod
    async def health_check(self) -> bool:
        """Check if the service is healthy"""
        pass

class RateLimiter:
    """Rate limiting implementation"""
    
    def __init__(self, requests_per_minute: int):
        self.requests_per_minute = requests_per_minute
        self.requests = []
    
    async def acquire(self):
        """Acquire rate limit token"""
        now = time.time()
        
        # Remove old requests
        self.requests = [req_time for req_time in self.requests if now - req_time < 60]
        
        # Check if we can make a request
        if len(self.requests) >= self.requests_per_minute:
            wait_time = 60 - (now - self.requests[0])
            if wait_time > 0:
                await asyncio.sleep(wait_time)
                return await self.acquire()
        
        self.requests.append(now)

class CircuitBreaker:
    """Circuit breaker implementation"""
    
    def __init__(self, threshold: int, timeout: int):
        self.threshold = threshold
        self.timeout = timeout
        self.failure_count = 0
        self.last_failure_time = None
        self.state = "closed"  # closed, open, half-open
    
    def is_open(self) -> bool:
        """Check if circuit breaker is open"""
        if self.state == "open":
            if time.time() - self.last_failure_time > self.timeout:
                self.state = "half-open"
                return False
            return True
        return False
    
    def record_success(self):
        """Record successful request"""
        self.failure_count = 0
        self.state = "closed"
    
    def record_failure(self):
        """Record failed request"""
        self.failure_count += 1
        self.last_failure_time = time.time()
        
        if self.failure_count >= self.threshold:
            self.state = "open"

# Specific Integration Implementations
# (Generate one class for each integration from the specifications)

class ExampleAPIIntegration(BaseIntegration):
    """Example external API integration"""
    
    async def health_check(self) -> bool:
        """Check API health"""
        try:
            response = await self.make_request("GET", "/health")
            return response.get("status") == "ok"
        except Exception as e:
            logger.error(f"Health check failed: {e}")
            return False
    
    async def create_item(self, item_data: Dict[str, Any]) -> Dict[str, Any]:
        """Create item via API"""
        return await self.make_request("POST", "/items", json=item_data)
    
    async def get_item(self, item_id: str) -> Dict[str, Any]:
        """Get item by ID"""
        return await self.make_request("GET", f"/items/{item_id}")
    
    async def update_item(self, item_id: str, item_data: Dict[str, Any]) -> Dict[str, Any]:
        """Update item"""
        return await self.make_request("PUT", f"/items/{item_id}", json=item_data)
    
    async def delete_item(self, item_id: str) -> bool:
        """Delete item"""
        await self.make_request("DELETE", f"/items/{item_id}")
        return True

class DatabaseIntegration(BaseIntegration):
    """Database integration example"""
    
    def __init__(self, config: IntegrationConfig):
        super().__init__(config)
        self.connection_pool = None
    
    async def connect(self):
        """Connect to database"""
        # Initialize database connection pool
        logger.info("Connected to database")
    
    async def disconnect(self):
        """Disconnect from database"""
        if self.connection_pool:
            # Close connection pool
            logger.info("Disconnected from database")
    
    async def health_check(self) -> bool:
        """Check database health"""
        try:
            # Perform simple query
            return True
        except Exception as e:
            logger.error(f"Database health check failed: {e}")
            return False
    
    async def execute_query(self, query: str, params: Optional[List] = None) -> List[Dict]:
        """Execute database query"""
        # Implement database query execution
        return []

class IntegrationManager:
    """Manages all external integrations"""
    
    def __init__(self):
        self.integrations: Dict[str, BaseIntegration] = {}
        self.configs: Dict[str, IntegrationConfig] = {}
        self.load_configurations()
    
    def load_configurations(self):
        """Load integration configurations from environment"""
        # Load from environment variables or config files
        self.configs = {
            "example_api": IntegrationConfig(
                base_url=os.getenv("EXAMPLE_API_URL", "https://api.example.com"),
                api_key=os.getenv("EXAMPLE_API_KEY"),
                timeout=int(os.getenv("EXAMPLE_API_TIMEOUT", "30")),
                max_retries=int(os.getenv("EXAMPLE_API_RETRIES", "3"))
            ),
            "database": IntegrationConfig(
                base_url=os.getenv("DATABASE_URL", "postgresql://localhost:5432/db"),
                timeout=int(os.getenv("DATABASE_TIMEOUT", "30"))
            )
        }
    
    async def initialize(self):
        """Initialize all integrations"""
        self.integrations = {
            "example_api": ExampleAPIIntegration(self.configs["example_api"]),
            "database": DatabaseIntegration(self.configs["database"])
        }
        
        # Connect to all integrations
        for name, integration in self.integrations.items():
            try:
                await integration.connect()
                logger.info(f"Initialized integration: {name}")
            except Exception as e:
                logger.error(f"Failed to initialize {name}: {e}")
    
    async def shutdown(self):
        """Shutdown all integrations"""
        for name, integration in self.integrations.items():
            try:
                await integration.disconnect()
                logger.info(f"Shutdown integration: {name}")
            except Exception as e:
                logger.error(f"Error shutting down {name}: {e}")
    
    async def get_integration(self, name: str) -> Optional[BaseIntegration]:
        """Get integration by name"""
        return self.integrations.get(name)
    
    async def health_check_all(self) -> Dict[str, bool]:
        """Check health of all integrations"""
        results = {}
        for name, integration in self.integrations.items():
            try:
                results[name] = await integration.health_check()
            except Exception as e:
                logger.error(f"Health check failed for {name}: {e}")
                results[name] = False
        return results
    
    async def get_metrics(self) -> Dict[str, Dict[str, int]]:
        """Get metrics from all integrations"""
        metrics = {}
        for name, integration in self.integrations.items():
            metrics[name] = {
                "requests": integration.request_count,
                "errors": integration.error_count,
                "circuit_breaker_state": integration.circuit_breaker.state
            }
        return metrics

# Factory function for easy integration creation
def create_integration_manager() -> IntegrationManager:
    """Create and return configured integration manager"""
    return IntegrationManager()

# Example usage
async def example_usage():
    """Example of how to use the integration manager"""
    manager = create_integration_manager()
    
    try:
        await manager.initialize()
        
        # Use specific integration
        api = await manager.get_integration("example_api")
        if api:
            result = await api.get_item("123")
            print(f"API result: {result}")
        
        # Check health of all integrations
        health = await manager.health_check_all()
        print(f"Health status: {health}")
        
        # Get metrics
        metrics = await manager.get_metrics()
        print(f"Metrics: {metrics}")
        
    finally:
        await manager.shutdown()

if __name__ == "__main__":
    asyncio.run(example_usage())
```

## Integration Features

The implementation includes:

1. **Base Integration Class**: Common functionality for all integrations
2. **Rate Limiting**: Prevent API rate limit violations
3. **Circuit Breaker**: Prevent cascading failures
4. **Retry Logic**: Exponential backoff for failed requests
5. **Connection Pooling**: Efficient connection management
6. **Health Checks**: Monitor integration health
7. **Metrics Collection**: Track performance and errors
8. **Configuration Management**: Environment-based configuration
9. **Error Handling**: Comprehensive error classification
10. **Async Support**: Non-blocking operations

## Usage in Main Agent

Integration with the main agent:

```python
# In agent-core.py
from integrations import IntegrationManager

class Agent:
    def __init__(self, config: AgentConfig):
        # ... other initialization
        self.integrations = IntegrationManager()
    
    async def initialize(self):
        await self.integrations.initialize()
    
    async def shutdown(self):
        await self.integrations.shutdown()
```

Generate robust integration code that handles all specified external systems with proper error handling and performance optimization.